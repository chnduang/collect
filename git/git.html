<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Git基础 | duangdong的collect</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端工程相关知识归纳总结">
    <meta name="keywords" content="qd-blog,vuepress,deploy,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.79da9109.css" as="style"><link rel="preload" href="/assets/js/app.6de842d1.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/48.6bf4d9f5.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.08b4924b.js"><link rel="prefetch" href="/assets/js/24.04e013f6.js"><link rel="prefetch" href="/assets/js/25.34294968.js"><link rel="prefetch" href="/assets/js/26.6cd6a2b2.js"><link rel="prefetch" href="/assets/js/27.292ba016.js"><link rel="prefetch" href="/assets/js/28.ad4889fd.js"><link rel="prefetch" href="/assets/js/29.40ddd368.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.4da9018d.js"><link rel="prefetch" href="/assets/js/31.94fcf72e.js"><link rel="prefetch" href="/assets/js/32.dd9a5c57.js"><link rel="prefetch" href="/assets/js/33.0e840cdc.js"><link rel="prefetch" href="/assets/js/34.22f6d84d.js"><link rel="prefetch" href="/assets/js/35.6c71aa30.js"><link rel="prefetch" href="/assets/js/36.fa16a4ae.js"><link rel="prefetch" href="/assets/js/37.742545d4.js"><link rel="prefetch" href="/assets/js/38.7edf2e2f.js"><link rel="prefetch" href="/assets/js/39.52168953.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.28420c4f.js"><link rel="prefetch" href="/assets/js/41.19d54d72.js"><link rel="prefetch" href="/assets/js/42.05502384.js"><link rel="prefetch" href="/assets/js/43.014a7ae4.js"><link rel="prefetch" href="/assets/js/44.803bf2b3.js"><link rel="prefetch" href="/assets/js/45.a60e397e.js"><link rel="prefetch" href="/assets/js/46.a1ec0ebe.js"><link rel="prefetch" href="/assets/js/47.1e484153.js"><link rel="prefetch" href="/assets/js/49.dc6882bc.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.91a545d9.js"><link rel="prefetch" href="/assets/js/51.5430a2bc.js"><link rel="prefetch" href="/assets/js/52.91d30b41.js"><link rel="prefetch" href="/assets/js/53.b114bb42.js"><link rel="prefetch" href="/assets/js/54.eba50797.js"><link rel="prefetch" href="/assets/js/55.0607fa87.js"><link rel="prefetch" href="/assets/js/56.a884aff5.js"><link rel="prefetch" href="/assets/js/57.789241af.js"><link rel="prefetch" href="/assets/js/58.df4d4f84.js"><link rel="prefetch" href="/assets/js/59.db90050e.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.8d10377d.js"><link rel="prefetch" href="/assets/js/61.a900a46f.js"><link rel="prefetch" href="/assets/js/62.bd1f2c84.js"><link rel="prefetch" href="/assets/js/63.2f626ca9.js"><link rel="prefetch" href="/assets/js/64.aab19556.js"><link rel="prefetch" href="/assets/js/65.3ede6ed7.js"><link rel="prefetch" href="/assets/js/66.5ccbf2d8.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.79da9109.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的collect</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/electron/" class="nav-link">
  Electron
</a></div><div class="nav-item"><a href="/python/" class="nav-link">
  Python
</a></div><div class="nav-item"><a href="/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/flutter/" class="nav-link">
  Flutter
</a></div><div class="nav-item"><a href="/android/" class="nav-link">
  部署
</a></div><div class="nav-item"><a href="/dataBase/" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/git/" class="nav-link router-link-active">
  Git
</a></div><div class="nav-item"><a href="https://link.aduang.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/electron/" class="nav-link">
  Electron
</a></div><div class="nav-item"><a href="/python/" class="nav-link">
  Python
</a></div><div class="nav-item"><a href="/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/flutter/" class="nav-link">
  Flutter
</a></div><div class="nav-item"><a href="/android/" class="nav-link">
  部署
</a></div><div class="nav-item"><a href="/dataBase/" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/git/" class="nav-link router-link-active">
  Git
</a></div><div class="nav-item"><a href="https://link.aduang.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/git/" aria-current="page" class="sidebar-link">Python</a></li><li><a href="/git/Introduce.html" class="sidebar-link">1.Linux</a></li><li><a href="/git/git.html" aria-current="page" class="active sidebar-link">Git基础</a></li><li><a href="/git/mac-ssh.html" class="sidebar-link">mac下自动保存 Git SSH Key 密码</a></li><li><a href="/git/service.html" class="sidebar-link">服务器的相关命令(以下均在Linux系统中)</a></li><li><a href="/git/shell.html" class="sidebar-link">shell</a></li><li><a href="/git/svn.html" class="sidebar-link">svn</a></li><li><a href="/git/version-control.html" class="sidebar-link">2.1    关于版本控制</a></li><li><a href="/git/vi—终端中的编辑器.html" class="sidebar-link">vi —— 终端中的编辑器</a></li><li><a href="/git/一份值得收藏的 Git 异常处理清单.html" class="sidebar-link">一份值得收藏的 Git 异常处理清单</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="git基础"><a href="#git基础" class="header-anchor">#</a> Git基础</h3> <p>命令行方式：任意目录（建议开发根目录）右键 &gt; Git Bash Here</p> <h5 id="_1、配置用户"><a href="#_1、配置用户" class="header-anchor">#</a> 1、配置用户</h5> <p>配置用户的意义在于记录开发者信息，以便在版本控制记录开发者的操作行为，如lion于2016-08-24解决了一个bug。</p> <p>git config --global user.name &quot;自已的名字&quot;</p> <p>git config --global user.email &quot;自已的邮箱地址&quot;</p> <p>--global 配置当前用户所有仓库</p> <p>--system 配置当前计算机上所有用户的所有仓库</p> <p>注：配置用户只需要执行1次，可以重复使用。</p> <h5 id="_2-初始化仓库"><a href="#_2-初始化仓库" class="header-anchor">#</a> 2，初始化仓库</h5> <p>我们如果想要利用git进行版本控制，需要将现有项目初始化为一个仓库，或者将一个已有的使用git进行版本控制的仓库克隆到本地。</p> <p>a) git init</p> <p>git init只是创建了一个名为.git的隐藏目录，这个目录就是存储我们历史版本的仓库，ls -al 可以查看。</p> <p>b) 假如公司已有项目用了Git，那我们就利用克隆</p> <p>git clone 仓库地址</p> <p>执行完这个命令，会在当前目录下生成一个Monment目录（默认和仓库名称相同），这个便是已有一个使用Git管理的项目。</p> <h5 id="_3-、查看文件状态"><a href="#_3-、查看文件状态" class="header-anchor">#</a> <strong>3</strong>**、查看文件状态**</h5> <p>初始化仓库后便可以进行开发了，进入到刚刚创建好并初始为仓库的目录，添加我们开发需要的文件。</p> <p>通过git status可以检测当前仓库文件的状态</p> <p>注：git会忽略空的目录</p> <h5 id="_4-、添加文件到暂存区"><a href="#_4-、添加文件到暂存区" class="header-anchor">#</a> <strong>4</strong>**、添加文件到暂存区**</h5> <p>假设经过一段时间的开发后，需要把已开发的部分存起来，使用git add 添加到暂存区。</p> <p>git add 文件名/ 文件路径 “*”或-A代表所有</p> <p>放到暂存区的文件被标记成了绿色，等待提交。</p> <p>注：颜色是工具给添加的，目的是增加可读性并不是git统一的。</p> <h5 id="_5、撤销更改"><a href="#_5、撤销更改" class="header-anchor">#</a> 5、撤销更改</h5> <p>继续我们的开发</p> <p>再次git status可以再次查看仓库状态</p> <p>说明index.html再次被修改了，并被标记了红色。</p> <p>又经过一段时间后发现新开发的部分有Bug，想要回到之前状态，可以使用git checkout 文件名。</p> <p>注：从暂存区还原原到工作区</p> <h5 id="_5-、提交文件"><a href="#_5-、提交文件" class="header-anchor">#</a> <strong>5</strong>**、提交文件**</h5> <p>经过一个相对较长阶段开发或者一个功能开发完成了，就可以提交到本地仓库了，永久保存了。</p> <p>git commit -m '备注信息'</p> <p>将暂存区被标记成绿色的文件，全部提交到本地仓库存储。</p> <p>这时git status查看状态</p> <p>没有什么可提交的，变的很干净。</p> <h5 id="_6-、查看提交历史"><a href="#_6-、查看提交历史" class="header-anchor">#</a> <strong>6</strong>**、查看提交历史**</h5> <p>反反复复开发了很多的功能了，通过git log查看一下提交的历史。</p> <p>我们可以查看到一次次提交记录</p> <p>commit 81b1e4fc2ae178caedf4575596377a80a6f1e73f</p> <p>代表一次提交的唯一ID，一般称为SHA值。傻？</p> <p>注：按键盘q键退出。</p> <h5 id="_7-、再次检测仓库文件状态"><a href="#_7-、再次检测仓库文件状态" class="header-anchor">#</a> <strong>7</strong>**、再次检测仓库文件状态**</h5> <p>隔了好些天后，继续开发</p> <p>git status 查看状态</p> <p>又提示有修改，等待重新添加到暂存区。</p> <h5 id="_8-、重新添加暂存区然后提交"><a href="#_8-、重新添加暂存区然后提交" class="header-anchor">#</a> <strong>8</strong>**、重新添加暂存区然后提交**</h5> <h5 id="_9-、再次查看历史"><a href="#_9-、再次查看历史" class="header-anchor">#</a> <strong>9</strong>**、再次查看历史**</h5> <p>git log 可查到所有提交历史</p> <p>这时可以查看到更多提交历史。</p> <p>这时关掉所有目录甚至关机！</p> <h5 id="_10-、恢复上一次提交的状态"><a href="#_10-、恢复上一次提交的状态" class="header-anchor">#</a> <strong>10</strong>**、恢复上一次提交的状态**</h5> <p>通过SHA值可以回到之前某一次的提交（时光倒流）</p> <p>git reset --hard c888a614e072e2这样便回到了支付功能的状态</p> <p>git log再次查看发现最后一次提交成了支付功能了</p> <p>仓库示意图</p> <h3 id="git分支"><a href="#git分支" class="header-anchor">#</a> Git分支</h3> <p>在我们的现实开发中，需求往往是五花八门的，同时开发个需求的情况十分常见，比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要你来修复，这个时候我们当然是希望在能够保存当前任务进度，再去修改这个BUG，等这个BUG修复完成后再继续我们的任务。如何实现呢？</p> <p>通过Git创建分支来解决实际开发中类似的问题。</p> <p>在Git的使用过程中一次提交称为历史记录（版本），并且会生成一个唯一的字符串，如下图</p> <p>这个串可以代表某一个历史版本（实际使用只取前面几位就可以），</p> <p>值得注意的是所有的提交（commit）实际上都是在分支（branch）的基础上进行的。</p> <p>如下图所示：</p> <p>当我们在初始化仓库的时候（实际上是产生第1次提交时），Git会默认帮我们创建了一个master的分支，并且有指针（HEAD）指到了末端。</p> <p>指针（HEAD）用来标明当前处于哪个分支的哪个版本，如上图指的处于master分支的最后1个版本。</p> <p>我们也可以创建自已的分支</p> <p><strong>1</strong>**、创建分支**</p> <p>git branch hotfix</p> <p>新的分支会在当前分支原有历史版本的结点上进行创建，我称其为子分支如下图</p> <p>新建的子分支会继承父分支的所有提交历史。</p> <p><strong>2</strong>**、切换分支**</p> <p>git checkout hotfix</p> <p>我们发现HEAD现在又指向了hotfix的末端。</p> <p><strong>3</strong>**、再次提交操作**</p> <p>修改bug后，提交</p> <p>这次的提交历史版本就会记录在hotfix这个分支上了，并且HEAD伴随hotfix在移动。</p> <p><strong>4</strong>**、当我们再次切回到<strong><strong>master</strong></strong>时**</p> <p>当我们切换回master后，HEAD指向了master分支的末端，并且我们观察发现我们的文件内容还是原来的“模样”。</p> <p><strong>5</strong>**、继续之前的开发**</p> <p>总结：当我们git checkout branchname时，HEAD会自动指向对应分支的末端，工作目录中的源码也会随之发生改变。</p> <p>这个时候我们就在hotfix这个分支上修复了这个BUG，而我们原来在master分支上的操作并未受到影响。</p> <p>思考一个问题：</p> <p>现在master这个分支上是否包含了hotfix的修复呢？</p> <p>实际上从上图可以看出这时的master分支并没有包含有hotfix的修复。</p> <p><strong>6</strong>**、合并（融合）分支**</p> <p>这时master会有两个父结点了，master便包含了hotfix里的修复了</p> <p><strong>7</strong>**、删除分支**</p> <p>git branch -d hotfix</p> <p>这时用来修复BUG创建的hotfix分支已经没有用处了，我们可以将它删除。</p> <h2 id="git远程-共享-仓库"><a href="#git远程-共享-仓库" class="header-anchor">#</a> Git远程（共享）仓库</h2> <p>通过上面学习我们可以很好的管理本地版本控制了，可是如果我们下班回到家里突然来了灵感觉得有部分代码可以优化，如果能接着公司电脑上的代码继续写该有多好呀！另一种情形，假设项目比较大，不同的功能模块由不同的开发人员完成，不同模块儿之间又难免会依赖关系，这时如果我们的代码互相合并（融合）该有多好呀！所有模块开发完毕后，需要整合到一起，要能做到准确无误该有多好呀！</p> <p>借助一个远程仓库，大家可以共享代码、历史版本等数据，便可以解决以上遇到的所有问题，在学习远程仓库前我们先来学习git clone path这个命令。</p> <p><strong>3</strong>**、创建共享仓库**</p> <p>Git要求共享仓库是一个以.git结尾的目录。</p> <p>mkdir repo.git 创建以.git结尾目录</p> <p>cd repo.git 进入这个目录</p> <p>git init --bare 初始化一个共享仓库，也叫裸仓库 注意选项--bare</p> <p>这样我们就建好了一个共享的仓库，但这时这个仓库是一个空的仓库，并且不允在这个仓库中进行任何修改。</p> <p><strong>4</strong>**、向共享仓库共享（同步）内容**</p> <p>将自已开发的项目同步到这个目录中，其它开发者就可以共享你开发的项目了。</p> <p>1、进入到yike目录</p> <p>2、git push ../repo.git master</p> <p>这样便把yike中的项目同步进了repo.git中。</p> <p><strong>5</strong>**、从共享仓库里取出内容**</p> <p>1、新创建一个目录（模拟另一个开发者）</p> <p>2、git clone ./repo.git demo</p> <p>通过repo.git共享仓库，我们轻松得到了一个yike的副本</p> <p><strong>6</strong>**、通过<strong><strong>demo</strong></strong>仓库向<strong><strong>repo.git</strong></strong>共享内容**</p> <p>进入到demo里，我们做一些修改</p> <p>cd demo</p> <p>git push ../repo.git master</p> <p><strong>7</strong>**、在<strong><strong>360</strong></strong>仓库从<strong><strong>repo.git</strong></strong>获取共享的内容**</p> <p>cd yike</p> <p>git pull ../repo.git master</p> <p>奇迹似乎发生了，我们轻松的将demo仓库里的内容，通过repo.git共享给了yike仓库。</p> <p>惊喜不断，问题也总是不断，我们发现我们这个共享的仓库只是放到了本地的，其它人是没有办法从我们这个共享仓库共享内容的！！！</p> <p>然而现实是，办法总是有的！！！！</p> <p>我们把这个共享的仓库放到一台远程服务器上，问题不就解决了吗？</p> <h2 id="github和gitlab"><a href="#github和gitlab" class="header-anchor">#</a> gitHub和gitLab</h2> <p>如果我们熟悉服务器的话，我们完全可以将上述的步骤在我们的远程服务器上进行操作，然后再做一些登录权限的设置，就可非常完美的搭建一个共享服务器了。其实为了更好的管理我们的仓库，一些第三方机构开发出了Web版仓库管理程序，通过Web界面形式管理仓库。</p> <p>gitHub关于它的名气与意义，大家可以自行查阅，我们这里介绍它的使用</p> <p><strong>1</strong>**、注册账号并完善资料**</p> <p><strong>2</strong>**、创建共享仓库*</p> <p><strong>3</strong>**、填写仓库资料**</p> <p><strong>4</strong>**、共享仓库**</p> <p>远程地址特别长，我们可以给他起一个别名</p> <p>git remote add origin git@github.com:Botue/repo.git</p> <p>这样origin 就代表 git@github.com:Botue/repo.git</p> <p>当我们通过git clone 从共享仓库获内容时，会自动帮我们添加origin到对应的仓库地址，例如：git clone git@github.com:Botue/repo.git 会自动添加origin 对应 git@github.com:Botue/repo.git</p> <p><strong>5</strong>**、生成密钥**</p> <p>ssh-keygen -t rsa 然后一路回车，这里会在当前用户生成了一个.ssh的文件夹</p> <p>将id_rsa.pub公钥的内容复制</p> <p>打开gitHub的个人中心</p> <p>打到SSH keys</p> <p>到此我们便可以通过gitHub 提供的Web界面来管理我们的仓库了。</p> <p>我们发现通过gitHub管理仓库实在是太方便了，可是只能免费使用公开仓库，自已公司的代码当然不能公开了，可是私有仓库又是需要交“保护费”的，无耐国人还是比较喜欢免费的，网络界总是有很多雷峰的，比如gitLab!!!</p> <p>gitLab也是一个可以通过Web界面管理仓库的网站程序，我们可以把它架设到公司自已的服务器上，实现仓库私有化，这也是大部分公司通常采用的方法，其使用方法与gitHub十分相似。</p> <p>我将闲置电脑配置成了一台服务器，上面架设了gitLab程序，我们接下来的练习全部会在gitLab上进行演示。</p> <p>省略很多内容.....</p> <h2 id="命令汇总"><a href="#命令汇总" class="header-anchor">#</a> 命令汇总</h2> <p>git config配置本地仓库</p> <p>常用git config --global user.name、git config --global user.email</p> <p>git config --list查看配置详情</p> <p>git init 初始一个仓库，添加--bare可以初始化一个共享（裸）仓库</p> <p>git status 可以查看当前仓库的状态</p> <p>git add“文件” 将工作区中的文件添加到暂存区中，其中file可是一个单独的文件，也可以是一个目录、“*”、-A</p> <p>git commit -m '备注信息' 将暂存区的文件，提交到本地仓库</p> <p>git log 可以查看本地仓库的提交历史</p> <p>git branch查看分支</p> <p>git branch“分支名称” 创建一个新的分支</p> <p>git checkout“分支名称” 切换分支</p> <p>git checkout -b deeveloper 他健并切到developer分支</p> <p>git merge“分支名称” 合并分支</p> <p>git branch -d “分支名称” 删除分支</p> <p>git clone “仓库地址”获取已有仓库的副本</p> <p>git push origin “本地分支名称:远程分支名称”将本地分支推送至远程仓库，</p> <p>git push origin hotfix（通常的写法）相当于</p> <p>git push origin hotfix:hotfix</p> <p>git push origin hotfix:newfeature</p> <p>本地仓库分支名称和远程仓库分支名称一样的情况下可以简写成一个，即git push “仓库地址” “分支名称”，如果远程仓库没有对应分支，将会自动创建</p> <p>git remote add “主机名称” “远程仓库地址”添加远程主机，即给远程主机起个别名，方便使用</p> <p>git remote 可以查看已添加的远程主机</p> <p>git remote show “主机名称”可以查看远程主机的信息</p> <h2 id="gitlab完整演示"><a href="#gitlab完整演示" class="header-anchor">#</a> GitLab完整演示</h2> <p>没错，Git非常强大！</p> <p>但是，如果我们的分支不加以规范管理，也有可能适得其反！</p> <p>1、不要有太多的树杈（子分支）</p> <p>2、要有一个“稳定分支”，即master分支不要轻意被修改</p> <p>3、要有一个开发分支（developer），保证master分支的稳定性</p> <p>4、所有的功能分支（feature）从developer创建</p> <p>5、所有功能开发完成后新建发布分支（release）</p> <h2 id="冲突解决"><a href="#冲突解决" class="header-anchor">#</a> 冲突解决</h2> <p>假如两个开发同时改到同一文件的同一段内容会发生什么事情呢？</p> <p>这时就会就会产生冲突了，当冲突产生后，需要开发者进行协商确认冲突的原因，然后将冲突代码删除重新提交就可以了。</p> <h2 id="git高级"><a href="#git高级" class="header-anchor">#</a> Git高级</h2> <p>熟悉掌握以上操作，基本上是可以满足日常开的需要的，但是在解决一些特殊问题时，就又需要我们能够掌握更多的命令。</p> <h3 id="gitignore忽略文件"><a href="#gitignore忽略文件" class="header-anchor">#</a> gitignore忽略文件</h3> <p>在项目根目录下创建一个.gitignore文件，可以将不希望提交的罗列在这个文件里，如项目的配置文件、node_modules等</p> <p>https://github.com/github/gitignore</p> <h3 id="比较差异"><a href="#比较差异" class="header-anchor">#</a> 比较差异</h3> <p>当内容被修改，我们无法确定修改哪些内容时，可以通过git diff来进行差异比较。</p> <p>git difftool 比较的是工作区和暂存的差异</p> <p>git difftool “SHA”比较与特定提交的差异</p> <p>git difftool “SHA”“SHA”比较某两次提交的差异</p> <p>git difftool 分支名称 比较与某个分支的差异</p> <p><strong>2</strong>**、回滚（撤销）操作**</p> <p>HEAD 默认指向当前分支的“末端”，即最后的一次提交，但是我们通过git reset 可以改变HEAD的指向。</p> <p><strong>看情况解释（稍微复杂一些，理解就好）</strong></p> <p>1、git reset</p> <p>--hard 工作区会变、历史(HEAD)会变， 暂存区也变</p> <p>--soft 只会变历史(HEAD)</p> <p>--mixed（默认是这个选项）历史(HEAD)会变、暂存区也变，工作区不变</p> <p>2、git checkout</p> <p>git checkout SHA -- &quot;某个文件&quot;，代表只是从SHA这个版中取出特定的文件，</p> <p>和git reset 是有区别的，reset 重写了历史，checkout 则没有。</p> <h3 id="更新仓库"><a href="#更新仓库" class="header-anchor">#</a> 更新仓库</h3> <p>在项目开发过程中，经常性的会遇到远程（共享）仓库和本地仓库不一致，我们可以通过git fetch 命令来更新本地仓库，使本地仓库和远程（共享）仓库保持一致。</p> <p>git fetch  “远程主机”</p> <p>或者</p> <p>git fetch “远程主机” “分支名称”</p> <p>我们要注意的是，利用git fetch 获取的更新会保存在本地仓库中，但是并没有体现到我们的工作目录中，需要我们再次利用git merge来将对应的分支合并（融合）到特定分支。如下</p> <p>git pull origin 某个分支， 上操作相当于下面两步</p> <p>git fetch</p> <p>git merge origin/某个分支</p> <p><strong>问题：如何查看远程主机上总共有多少个分支？</strong></p> <p>git branch -a 便可以查看所有(本地+远程仓库)分支了</p> <h2 id="其它"><a href="#其它" class="header-anchor">#</a> 其它</h2> <p>删除远程分支git push origin --delete 分支名称</p> <p>删除远程分支git push origin :分支名称</p> <h3 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h3> <div class="language- extra-class"><pre class="language-text"><code>git tag
git push --tags

</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>我们有时会遇到这样的情况，正在dev分支开发新功能，做到一半时有人过来反馈一个bug，让马上解决，但是新功能做到了一半你又不想提交，这时就可以使用git stash命令先把当前进度保存起来，然后切换到另一个分支去修改bug，修改完提交后，再切回dev分支，使用git stash pop来恢复之前的进度继续开发新功能。下面来看一下git stash命令的常见用法

git stash
保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save <span class="token string">'message...'</span>可以添加一些注释

git stash list
显示保存进度的列表。也就意味着，git stash命令可以多次执行。

git stash pop <span class="token punctuation">[</span>–index<span class="token punctuation">]</span> <span class="token punctuation">[</span>stash_id<span class="token punctuation">]</span>
git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。
git stash pop <span class="token operator">--</span>index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）
git stash pop stash@<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span>恢复指定的进度到工作区。stash_id是通过git stash list命令得到的
通过git stash pop命令恢复进度后，会删除当前进度。
git stash apply <span class="token punctuation">[</span>–index<span class="token punctuation">]</span> <span class="token punctuation">[</span>stash_id<span class="token punctuation">]</span>
除了不删除恢复的进度之外，其余和git stash pop 命令一样。

git stash drop <span class="token punctuation">[</span>stash_id<span class="token punctuation">]</span>
删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。

git stash clear
删除所有存储的进度。
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> 基本使用
stash命令可用于临时保存和回复修改，可跨分支。

注：在未add之前才能执行stash！！！！

git stash <span class="token punctuation">[</span>save message<span class="token punctuation">]</span>
保存，save为可选项，message为本次保存的注释
git stash list
所有保存的记录列表
git stash pop stash@<span class="token punctuation">{</span>num<span class="token punctuation">}</span>
恢复，num是可选项，通过git stash list可查看具体值。只能恢复一次
git stash apply stash@<span class="token punctuation">{</span>num<span class="token punctuation">}</span>
恢复，num是可选项，通过git stash list可查看具体值。可回复多次
git stash drop stash@<span class="token punctuation">{</span>num<span class="token punctuation">}</span>
删除某个保存，num是可选项，通过git stash list可查看具体值
git stash clear
删除所有保存

</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/git/Introduce.html" class="prev">
        1.Linux
      </a></span> <span class="next"><a href="/git/mac-ssh.html">
        mac下自动保存 Git SSH Key 密码
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.6de842d1.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/48.6bf4d9f5.js" defer></script>
  </body>
</html>
