(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{320:function(n,e,t){"use strict";t.r(e);var o=t(4),s=Object(o.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("### 1.将数组转化成字符串\n\n##### \t\tJSON.stringify(obj)\n\n------\n\n### 2.将字符串转化成数组\n\n##### \tJSON.parse(string)\n\n------\n\n### 3.`art-template`\n\n##### \t{{each 数组}}\n\n​\t\t<li>{{$value}}</li>                // $value   即是item ，遍历的每一项\n\n##### \t{{/each}}\n\n##### \t*这是art-template的模板语法，专有的\n\n##### +$.each(数组,function(){ })\n\n##### +$(' div ').each(function(){ })\n\n​\t+一般用于遍历jQuery选择到的伪数组实例对象\n\n​\t\t+ 伪数组是对象可将其转化为数组：\n\n​\t\t+ 对象的原型链中没有forEach这个方法\n\n​\t\t+ 对象的原型链是  Object.prototype\n\n​\t\t+ 这个each是jQuery提供的 \t\n\n​```javascript\n;[].slice.call($('div'))\n//slice() 不传参数时，默认从截取全部\n//slice(1,2) 不包含右边 \n​```\n\n##### +forEach 是 Ecmascript 5中的一个数组遍历函数 ，是javascript 原生支持的遍历方法，\n\n​\t+不兼容低版本的浏览器，IE8开始\n\n------\n\n### 4.如何在`Node`中实心服务器的重定向\n\n##### + header('location')\n\n##### \t*301 永久重定向 浏览器会记住\n\n​\t\t-a.com b.com\n\n​\t\t-a 浏览器不会再请求a了\n\n​\t\t-会直接跳到 b 了\n\n##### \t*302 临时重定向 l浏览器不会记忆\n\n​\t\t-a.com b.com\n\n​\t\t-a 还是会请求a\n\n​\t\t-a 告诉浏览器往 b 跳转\n\n------\n\n### 5.`Node`中的模块系统\n\n+使用node编写的应用程序主要就是用在\n\n##### \t+Ecmascript语言\n\n##### \t+核心模块\n\n​\t\t-fs 文件操作的fs\n\n​\t\t-http 服务的http\n\n​\t\t-url 路径操作模板\n\n​\t\t-path 路径处理模板\n\n​\t\t-os 操作系统信息\n\n##### \t+第三方模块\n\n​\t\t- art-template\n\n​\t\t-必须通过`npm` 下载使用的\n\n##### \t+自己写的模块\n\n​\t\t-文件路径\n\n### 6.`commonJs` 模块规范\n\n##### 6.1\t在Node中有一个很重要的概念的：模块系统\n\n​\t+模块作用域\n\n​\t+使用require 方法来加载模块\n\n​\t+使用exports 接口对象来导出模块中的成员\n\n+++\n\n### 7.`exports`和`module.exports`的区别\n\n#### 7.1\t简单比较\n\n##### +Node 中是模块作用域，默认的文件中的所有成员只在当前文件模块生效\n\n+对与希望可以被其他模块访问的信息，我们就需要把这些公开的成员都挂载到`exports`\n\n接口对象中就可以了。\n\n+导出多个成员（必须在对象中）\n\n​```javascript\nexports.a = 123\nexports.b = 'hello'\nexports.c = function(){\n    console.log('ccc')\n}\nexports.d = {\n    foo: 'bar'\n}\n​```\n\n+导出单个成员（拿到的就是：函数，字符串）\n\n​```javascript\nmodule.exports = 'hello'\n\nmodule.exports = function(){ \n\n}\n//后面的会覆盖前面的\n​```\n\n+也可以导出多个成员\n\n​```javascript\nmodule.export = {\n    add:function(){\n        return x+y\n    },\n    str:'hello'\n}\n​```\n\n#### 7.1\t原理解析\n\n+`exports`和`module.exports`的一个引用：\n\n​```javascript\nconsole.log(exports === module.exports)      //true\n\nexports.foo = 'bar'\n//等价于\nmodule.exports.foo = 'bar'\n​```\n\n+++\n\n#### 7.2具体分析\n\n+我们发现，每次导出接口成员的时候都通过 module.exports.xxx = xxx 的方式很麻烦，点儿的太多了所以，Node 为了简化你的操作，专门提供了一个变量：exports 等于 module.exports\n\n​```javascript\n var module = {\n   exports: {\n     foo: 'bar',\n     add: function\n   }\n }\n​```\n\n// 也就是说在模块中还有这么一句代码\n\n​```javascript\n// var exports = module.exports\n\n// module.exports.foo = 'bar'\n\n// module.exports.add = function (x, y) {\n//   return x + y\n// }\n​```\n\n// 两者一致，那就说明，我可以使用任意一方来导出内部成员\n\n​```javascript\n// console.log(exports === module.exports)\n\n// exports.foo = 'bar'\n// module.exports.add = function (x, y) {\n//   return x + y\n// }\n​```\n\n// 当一个模块需要导出单个成员的时候\n// 直接给 exports 赋值是不管用的\n\n​```javascript\n// exports.a = 123// exports = {}// exports.foo = 'bar'// module.exports.b = 456// 给 exports 赋值会断开和 module.exports 之间的引用// 同理，给 module.exports 重新赋值也会断开// 这里导致 exports !== module.exports// module.exports = {//   foo: 'bar'// }// // 但是这里又重新建立两者的引用关系// exports = module.exports// exports.foo = 'hello'// {foo: bar}exports.foo = 'bar'// {foo: bar, a: 123}module.exports.a = 123// exports !== module.exports// 最终 return 的是 module.exports\n​```\n\n// 所以无论你 exports 中的成员是什么都没用\n\n​```javascript\nexports = {  a: 456}// {foo: 'haha', a: 123}module.exports.foo = 'haha'// 没关系，混淆你的exports.c = 456// 重新建立了和 module.exports 之间的引用关系了exports = module.exports// 由于在上面建立了引用关系，所以这里是生效的// {foo: 'haha', a: 789}exports.a = 789// 前面再牛逼，在这里都全部推翻了，重新赋值// 最终得到的是 Functionmodule.exports = function () {  console.log('hello')}// 真正去使用的时候：//    导出多个成员：exports.xxx = xxx//    导出多个成员也可以：module.exports = {//                        }//    导出单个成员：module.exports\n​```\n\n+++\n\n### 8.Node中的require         \n\n> 一个项目中有且只有 `node_modules`  而且是存放在项目的根目录中的\n>\n> 这样的话项目中所哟子目录中的代码都可以加载到第三方包\n>\n> 不会出现有多个`node_modules`\n\n#### 8.1 加载的模块\n\n##### \t+核心模块\n\n​\t\t-本质也是文件\n\n​\t\t-核心模块已经被编译到了二进制文件中了\n\n##### \t+第三方模块\n\n​\t\t-必须从npm 下载的模块\n\n​\t\t-使用的时候就可以通过 require('包名') 的方式来进行加载才可以使用\n​\t\t-不可能有任何一个第三方包和核心模块的名字是一样的\n​\t\t-既不是核心模块、也不是路径形式的模块\n​\t\t-先找到当前文件所处目录中的 node_modules 目录\n​\t\t-node_modules/art-template\n​\t\t-node_modules/art-template/package.json 文件\n​\t\t-node_modules/art-template/package.json 文件中的 main 属性\n​\t\t-main 属性中就记录了 art-template 的入口模块\n​\t\t-然后加载使用这个第三方包\n​\t\t-实际上最终加载的还是文件( index.js )\t\n\n##### \t+自己写的模块\n\n#### 8.2 加载规则\n\n> 详细见《深入浅出NodeJs》模块部分\n\n​\t+优先从缓存加载     （node底层做的）\n\n​\t\t-不会重复加载\n\n​\t\t-拿到其中的接口对象\n\n​\t\t-避免重复加载，提高模块加载的效率\n\n​\t+核心模块\n\n​\t+路径形式的文件模块\n\n​\t+第三方模块\n\n​\t+判断模块标识\n\n------\n\n### 9.npm\n\n#### 9.1 package.json\n\n+ 建议每一个项目都有一个`package.json`            \n  + npm init\n  + npm init -y         //跳过向导，快速生成\n  + npm install --save jquery\t//保存依赖信息\n  + npm install         //会下载package.json 文件下的所有依赖\n\n+ `package.json`和`package-lock.json`\n\n  + npm5 以前是不会有package-lock.json这个文件的\n  + npm5以后才会有\n  + npm5 以后的安装包不需要 `--save`的参数，它会自动保存依赖项\n  + `package-lock.json`这个文件会保存`node_modules`中的所有包的依赖 \n  + 当`node_modules`删除重新安装的时候，安装的速度会更快\n  + `lock`是锁定版本的\n    + 如果这个项目依赖了`1.11.1`\n    + 如果你重新安装install 其实是会安装最新的版本\n    + 它会锁定我们当时使用的版本，不让他自动升级\n\n\n#### 9.2 相关命令\n\n+ 版本号：\n  + npm --version\n+ 升级(自己升级自己)\n  + npm install --global npm\n\n##### 9.2.1 常用命令\n\n+ npm uninstall --save jquery\n\n  + 删除时，依赖也会删除\n\n+ npm uninstall --help \n\n  + 获取帮助\n\n+ 配置淘宝镜像r\n\n  + ```shell\n    npm config set registry https://registry.npm.taobao.org#查看配置信息npm config list\n    ```\n\n------\n\n### 10.相对路径\n\n+ 模块加载中，相对路径 ./ 不能省略\n\n+ 文件加载时，相对路径 ./ 可以省略\n\n  > fs.readFile() 和ajax一样，都是异步操作，最后执行\n\n------\n\n### 11.修改完代码自动重启服务器\n\n+ 可以使用第三方的命令行工具，`nodemon`解决频繁修改代码重启服务器的问题\n\n+ nodemon 是一个基于NodeJs开发的一个第三方命令行工具，使用时需要全局安装\n\n+ ```shell\n  npm install -g nodemon#安装之后使用#nodemon app.js\n")])])]),e("hr"),n._v(" "),e("h3",{attrs:{id:"_12-路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-路由"}},[n._v("#")]),n._v(" 12.路由")]),n._v(" "),e("h4",{attrs:{id:"_12-1基本路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-1基本路由"}},[n._v("#")]),n._v(" 12.1基本路由")]),n._v(" "),e("p",[e("strong",[n._v("get")]),n._v(":")]),n._v(" "),e("p",[n._v("​"),e("code",[n._v("javascript //当以GET的方式请求的时候，执行对应的处理函数app.get('/', function(req,res){ res.send('hello');}); ​")])]),n._v(" "),e("p",[e("strong",[n._v("post")]),n._v(":")]),n._v(" "),e("p",[n._v("​"),e("code",[n._v("javascript //当以POST的方式请求的时候，执行对应的处理函数app.post('/', function(req,res){ res.send('hello post');}); ​")])]),n._v(" "),e("h4",{attrs:{id:"_12-2-在express中配置使用art-template模板引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-在express中配置使用art-template模板引擎"}},[n._v("#")]),n._v(" 12.2 在"),e("code",[n._v("express")]),n._v("中配置使用"),e("code",[n._v("art-template")]),n._v("模板引擎")]),n._v(" "),e("p",[n._v("安装：")]),n._v(" "),e("blockquote",[e("p",[n._v("express-art-template 依赖了art-template")])]),n._v(" "),e("p",[n._v("​"),e("code",[n._v("shell npm install --save art-templatenpm install --save express-art-template ​")])]),n._v(" "),e("p",[n._v("配置：")]),n._v(" "),e("blockquote",[e("p",[n._v("express 为 response 相应对象提供了一个方法 ： render")]),n._v(" "),e("p",[n._v("render 方法默认是不可以使用的， 但是如果配置了模板引擎就可以使用了")]),n._v(" "),e("p",[n._v("res.render('html模板名称'，{模板数据})")]),n._v(" "),e("p",[n._v("第一个参数不能路径，默认会去项目中的views目录中查找模板文件")]),n._v(" "),e("p",[n._v("也就是说express有一个约定，开发人员把所有的视图文件都放在  views 目录中了")])]),n._v(" "),e("p",[n._v("​"),e("code",[n._v("javascript app.engine('html',require('express-art-template'));app.get('/',function(req,res){ res.render('index.html');})app.get('/admin', function(req,res){ res.render('admin/index.html',{ });}) ​")])]),n._v(" "),e("p",[n._v("如果希望修改默认的"),e("code",[n._v("views")]),n._v("视图渲染存储目录，可以通过")]),n._v(" "),e("p",[n._v("​"),e("code",[n._v("javascript app.set('views',目录路径)； ​")])]),n._v(" "),e("h4",{attrs:{id:"_12-3-在express中获取表单post请求体数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-在express中获取表单post请求体数据"}},[n._v("#")]),n._v(" 12.3 在express中获取表单post请求体数据")]),n._v(" "),e("p",[n._v("在express中没又内置获取表单post请求体的API，这里我们需要使用一个第三方包，"),e("code",[n._v("body-parser")])]),n._v(" "),e("blockquote",[e("p",[n._v("在get中是express中内置了一个方法获取请求体，res.query")]),n._v(" "),e("p",[n._v("post:   res.body")])]),n._v(" "),e("p",[n._v("安装：")]),n._v(" "),e("p",[n._v("​"),e("code",[n._v("shell npm install body-parser --save ​")])]),n._v(" "),e("p",[n._v("配置示例：")]),n._v(" "),e("p",[n._v("​"),e("code",[n._v("javascript var express = require('express')var bodyParser = require('body-parser')var app = express()//加入这个配置之后，多一个 req.body 拿到请求体的对象// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded({ extended: false }))// parse application/jsonapp.use(bodyParser.json())app.use(function (req, res) { res.setHeader('Content-Type', 'text/plain') res.write('you posted:\\n') res.end(JSON.stringify(req.body, null, 2))}) ​")])]),n._v(" "),e("h3",{attrs:{id:"_13-异步函数封装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-异步函数封装"}},[n._v("#")]),n._v(" 13.异步函数封装")]),n._v(" "),e("p",[n._v("异步方法：")]),n._v(" "),e("ul",[e("li",[n._v("setTimeout")]),n._v(" "),e("li",[n._v("readFile")]),n._v(" "),e("li",[n._v("writeFile")]),n._v(" "),e("li",[n._v("reddir")]),n._v(" "),e("li",[n._v("ajax")])]),n._v(" "),e("blockquote",[e("p",[n._v("用回调函数调用异步的结果")])]),n._v(" "),e("h3",{attrs:{id:"_14-path-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-path-方法"}},[n._v("#")]),n._v(" 14.path 方法")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("path.basename")]),n._v(" "),e("ul",[e("li",[n._v("获取一个路径的文件名")])])]),n._v(" "),e("li",[e("p",[n._v("path.dirname")]),n._v(" "),e("ul",[e("li",[n._v("获取一个路径中的目录部分")])])]),n._v(" "),e("li",[e("p",[n._v("path.extname")]),n._v(" "),e("ul",[e("li",[n._v("获取一路径中的扩展名部分")])])]),n._v(" "),e("li",[e("p",[n._v("path.join")]),n._v(" "),e("ul",[e("li",[n._v("路径的拼接")])])]),n._v(" "),e("li",[e("p",[n._v("path.isAbsolute")]),n._v(" "),e("ul",[e("li",[n._v("判断一个路径是否是绝对路径")])])]),n._v(" "),e("li",[e("p",[n._v("path.parse()")]),n._v(" "),e("ul",[e("li",[n._v("把一个路径转为一个对象")])])])]),n._v(" "),e("p",[n._v("​"),e("code",[n._v("shell path.parse('e:/a/b/c/d.html') ​")])]),n._v(" "),e("ul",[e("li",[e("p",[n._v("__dirname 可以用来获取当前文件模块所属目录的绝对路径")])]),n._v(" "),e("li",[e("p",[n._v("__filename 可以用来获取当前文件的绝对路径")]),n._v(" "),e("ul",[e("li",[e("blockquote",[e("p",[n._v("两者都是动态获取的")])])])])]),n._v(" "),e("li",[e("p",[n._v("在文件操作中，使用相对路径是不可靠的，因为在"),e("code",[n._v("Node")]),n._v("中文件操作的路径被设计为相对于执行"),e("code",[n._v("Node")]),n._v("命令所处的路径 (这不是bug 这样设计是有使用场景的)。在require()中不会影响，可使用相对路径。")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("为了解决这个问题，很简单，只需要将相对路径换成绝对路径即可")])]),n._v(" "),e("li",[e("p",[n._v("可以使用"),e("code",[n._v("__dirname")]),n._v("或者"),e("code",[n._v("__filename")]),n._v("帮我们解决这个问题")])]),n._v(" "),e("li",[e("p",[n._v("推荐使用"),e("code",[n._v("path.join()")]),n._v("来帮我们解决拼接路径，避免我们手动拼接出现问题")])])])])]),n._v(" "),e("h3",{attrs:{id:"_15"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15"}},[n._v("#")]),n._v(" 15.")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);